function [p MSH]=extrude_mesh(p_2d,MSH_2d,top,bot,t,el_order)
% [p MSH]=extrude_mesh(p_2d,MSH_2d,top,bot,t,el_order)
% Extrudes the 2D mesh to 3D
%
% Input 
% p_2d :    Coordinates of 2D mesh nodes
% MSH_2d :  Mesh structure generated by Gmsh.
% top:      top elevation of the 2D mesh nodes
% bot:      bottom elevation of the 2D mesh nodes
% t : parametric variable that defines how many layers will be generated
%     and their vertical distribution between the top and bottom elevation. 
%     The t values must be t(1) = 0 (corresponds to bottom elevation)
%                           t(end) = 1 (coresponds to top elevation)
%     A quick way to plot the layer distribution is 
%     plot(ones(length(t),1),t,'.-')
% el_order : element order 'linear' or 'quadratic'. At the moment incomplete
%            elements cannot be used
% Output 
% p : 3D coordinates
% 
% MSH : 3D mesh structure
%
%
% Version : 1.0
% Author : George Kourakos
% email: giorgk@gmail.com
% web : http://groundwater.ucdavis.edu/msim
% Date 25-Mar_2013 (Imera Anexartisias)
% Department of Land Air and Water
% University of California Davis


switch el_order
    case 'linear'
        
        %First extrude the points
        Nlay=length(t);
        Np_per_lay=size(p_2d,1);
        Z=nan(Np_per_lay,Nlay);
        Z(:,1)=top;
        Z(:,Nlay)=bot;
        for i=2:Nlay-1;
            Z(:,i)=Z(:,1)*t(Nlay-i+1)+Z(:,Nlay)*(1-t(Nlay-i+1));
        end

        Np=Np_per_lay*Nlay;
        p=nan(Np,3);
        for i=1:Nlay
            p((i-1)*Np_per_lay+1:i*Np_per_lay,:)=[p_2d(:,1:2) Z(:,i)];
        end
        
        ngr=ones(4,1);
        
        if isfield(MSH_2d(1,1),'elem')
            for jj=1:size(MSH_2d(1,1).elem,1)
                MSH(1,1).elem(ngr(1),1).type='BndPnt';
                MSH(1,1).elem(ngr(1),1).id=[];
                if isempty(MSH_2d(1,1).elem(jj,1).id)
                    break
                end
                
                %copy the points of 2D mesh to 3D mesh. These  correspond to top layer
                MSH(1,1).elem(ngr(1),1).id=MSH_2d(1,1).elem(jj,1).id;
                %add the points of the bottom layer
                MSH(1,1).elem(ngr(1),1).id=[MSH(1,1).elem(ngr(1),1).id;...
                    MSH_2d(1,1).elem(jj,1).id+(Nlay-1)*Np_per_lay];
                %last for each point of the 2D mesh corresponds a vertical line in the 3D
                %mesh
                
                MSH(2,1).elem(ngr(2),1).type='line';
                MSH(2,1).elem(ngr(2),1).id=nan(length(MSH_2d(1,1).elem(jj,1).id)*(Nlay-1),2);
                cnt=1;
                for j=1:length(MSH_2d(1,1).elem(jj,1).id)
                    for k=1:Nlay-1
                        MSH(2,1).elem(ngr(2),1).id(cnt,:)=[...
                           (k-1)*Np_per_lay+MSH_2d(1,1).elem(jj,1).id(j) ...
                            k*Np_per_lay+MSH_2d(1,1).elem(jj,1).id(j)];
                        cnt=cnt+1;
                    end
                end
                ngr(1)=ngr(1)+1;
                ngr(2)=ngr(2)+1;
            end
        end
        
        if isfield(MSH_2d(2,1),'elem')
            for jj=1:size(MSH_2d(2,1).elem,1)
                MSH(2,1).elem(ngr(2),1).type='line';
                MSH(2,1).elem(ngr(2),1).id=[];
                if isempty(MSH_2d(2,1).elem(jj,1).id)
                    continue
                end
                
                %copy the lines of the 2D mesh which correspond to the lines of the top face
                MSH(2,1).elem(ngr(2),1).id=[MSH(2,1).elem(ngr(2),1).id;MSH_2d(2,1).elem(jj,1).id];
                %add the lines of the bottom surface
                MSH(2,1).elem(ngr(2),1).id=[MSH(2,1).elem(ngr(2),1).id;MSH_2d(2,1).elem(jj,1).id+(Nlay-1)*Np_per_lay];
                %for each line create a face and add it on the 3 row of the MSH.
                %these will always be quadrilaterals
                MSH(3,1).elem(ngr(3),1).type='quad';
                MSH(3,1).elem(ngr(3),1).id=nan(size(MSH_2d(2,1).elem(jj,1).id,1)*(Nlay-1),4);
                cnt=1;
                for j=1:size(MSH_2d(2,1).elem(jj,1).id,1)
                    for k=1:Nlay-1
                        MSH(3,1).elem(ngr(3),1).id(cnt,:)=[...
                            (k-1)*Np_per_lay+MSH_2d(2,1).elem(jj,1).id(j,[1,2]) ...
                             k*Np_per_lay+MSH_2d(2,1).elem(jj,1).id(j,[2,1])];
                         cnt=cnt+1;
                    end
                end
                ngr(2)=ngr(2)+1;
                ngr(3)=ngr(3)+1;
            end
        end
        
        
        if isfield(MSH_2d(3,1),'elem')
            for jj=1:size(MSH_2d(3,1).elem,1)
                if isempty(MSH_2d(3,1).elem(jj,1).id)
                    continue
                end
                switch MSH_2d(3,1).elem(jj,1).type
                    case 'quad'
                        MSH(3,1).elem(ngr(3),1).type='quad';
                        MSH(3,1).elem(ngr(3),1).id=[];
                        MSH(3,1).elem(ngr(3),1).id=[MSH(3,1).elem(ngr(3),1).id;...
                            MSH_2d(3,1).elem(jj,1).id];
                            MSH(3,1).elem(ngr(3),1).id=[MSH(3,1).elem(ngr(3),1).id;...
                                MSH_2d(3,1).elem(jj,1).id+(Nlay-1)*Np_per_lay];
                            ngr(3)=ngr(3)+1;
                    case 'triangle'
                        MSH(3,1).elem(ngr(3),1).type='triangle';
                        MSH(3,1).elem(ngr(3),1).id=[];
                        MSH(3,1).elem(ngr(3),1).id=[MSH(3,1).elem(ngr(3),1).id;...
                            MSH_2d(3,1).elem(jj,1).id];
                        MSH(3,1).elem(ngr(3),1).id=[MSH(3,1).elem(ngr(3),1).id;...
                            MSH_2d(3,1).elem(jj,1).id+(Nlay-1)*Np_per_lay];
                        ngr(3)=ngr(3)+1;
                end
                %Last create the prism or hexahedrals
                switch MSH_2d(3,1).elem(jj,1).type
                    case 'quad'
                        MSH(4,1).elem(ngr(4),1).type='hex';
                        MSH(4,1).elem(ngr(4),1).id=[];
                        for k=1:Nlay-1
                            MSH(4,1).elem(ngr(4),1).id=[MSH(4,1).elem(ngr(4),1).id; ...
                                k*Np_per_lay+MSH_2d(3,1).elem(jj,1).id ...
                                (k-1)*Np_per_lay+MSH_2d(3,1).elem(jj,1).id];
                        end
                        ngr(4)=ngr(4)+1;
                    case 'triangle'
                        MSH(4,1).elem(ngr(4),1).type='prism';
                        MSH(4,1).elem(ngr(4),1).id=[];
                        for k=1:Nlay-1
                            MSH(4,1).elem(ngr(4),1).id=[MSH(4,1).elem(ngr(4),1).id; ...
                                k*Np_per_lay+MSH_2d(3,1).elem(jj,1).id ...
                                (k-1)*Np_per_lay+MSH_2d(3,1).elem(jj,1).id];

                        end
                        ngr(4)=ngr(4)+1;
                        
                end     
                        
            end
        end
    case 'quadratic'
        %First extrude the points
        Nlay=length(t);
        % in quadratic elements of each layer there will be an intermediate
        % layer
        t=[reshape([t(1:end-1)' (t(2:end)'+t(1:end-1)')/2]',2*(length(t)-1),1); t(end)];
        % Nl is the fake number of layers
        Nl=length(t);
        Np_per_lay=size(p_2d,1);
        Z=nan(Np_per_lay,Nl);
        Z(:,1)=top;
        Z(:,Nl)=bot;
        for i=2:Nl-1;
            Z(:,i)=Z(:,1)*t(Nl-i+1)+Z(:,Nl)*(1-t(Nl-i+1));
        end

        Np=Np_per_lay*Nl;
        p=nan(Np,3);
        for i=1:Nl
            p((i-1)*Np_per_lay+1:i*Np_per_lay,:)=[p_2d(:,1:2) Z(:,i)];
        end
        
        ngr=ones(4,1);
        if isfield(MSH_2d(1,1),'elem')
            for jj=1:size(MSH_2d(1,1).elem,1)
                MSH(1,1).elem(ngr(1),1).type='BndPnt';
                MSH(1,1).elem(ngr(1),1).id=[];
                if isempty(MSH_2d(1,1).elem(jj,1).id)
                    break
                end
                
                %copy the points of 2D mesh to 3D mesh. These  correspond to top layer
                MSH(1,1).elem(ngr(1),1).id=MSH_2d(1,1).elem(jj,1).id;
                %add the points of the bottom layer
                MSH(1,1).elem(ngr(1),1).id=[MSH(1,1).elem(ngr(1),1).id;...
                    MSH_2d(1,1).elem(jj,1).id+(Nl-1)*Np_per_lay];
                
                %last for each point of the 2D mesh corresponds a vertical line in the 3D
                %mesh
                MSH(2,1).elem(ngr(2),1).type='line';
                MSH(2,1).elem(ngr(2),1).id=[];
                for j=1:length(MSH_2d(1,1).elem(jj,1).id)
                    for k=1:Nlay-1
                        MSH(2,1).elem(ngr(2),1).id=[MSH(2,1).elem(ngr(2),1).id;...
                            (2*k-2)*Np_per_lay+MSH_2d(1,1).elem(jj,1).id(j) ...
                            2*k*Np_per_lay+MSH_2d(1,1).elem(jj,1).id(j) ...
                            (2*k-1)*Np_per_lay+MSH_2d(1,1).elem(jj,1).id(j)];
                    end
                end
                ngr(1)=ngr(1)+1;
                ngr(2)=ngr(2)+1;
            end
        end
        
        if isfield(MSH_2d(2,1),'elem')
            for jj=1:size(MSH_2d(2,1).elem,1)
                if isempty(MSH_2d(2,1).elem(jj,1).id)
                    continue
                end
                MSH(2,1).elem(ngr(2),1).type='line';
                MSH(2,1).elem(ngr(2),1).id=[];
                %copy the lines of the 2D mesh which correspond to the lines of the top face
                MSH(2,1).elem(ngr(2),1).id=[MSH(2,1).elem(ngr(2),1).id;MSH_2d(2,1).elem(jj,1).id];
                %add the lines of the bottom surface
                MSH(2,1).elem(ngr(2),1).id=[MSH(2,1).elem(ngr(2),1).id;MSH_2d(2,1).elem(jj,1).id+(Nl-1)*Np_per_lay];
                %for each line create a face and add it on the 3 row of the MSH.
                %these will always be quadrilaterals
                MSH(3,1).elem(ngr(3),1).type='quad';
                MSH(3,1).elem(ngr(3),1).id=[];
                for j=1:size(MSH_2d(2,1).elem(jj,1).id,1)
                    for k=1:Nlay-1
                        a=(2*k-2)*Np_per_lay+MSH_2d(2,1).elem(jj,1).id(j,:);
                        b=2*k*Np_per_lay+MSH_2d(2,1).elem(jj,1).id(j,:);
                        c=(2*k-1)*Np_per_lay+MSH_2d(2,1).elem(jj,1).id(j,:);
                        MSH(3,1).elem(ngr(3),1).id=[MSH(3,1).elem(ngr(3),1).id; ...
                            a(1) a(2) b(2) b(1) a(3) c(2) b(3) c(1) c(3)];
                    end
                end
                ngr(2)=ngr(2)+1;
                ngr(3)=ngr(3)+1;
            end
        end
        
        if isfield(MSH_2d(3,1),'elem')
            for jj=1:size(MSH_2d(3,1).elem,1)
                if isempty(MSH_2d(3,1).elem(jj,1).id)
                    continue
                end
                switch MSH_2d(3,1).elem(jj,1).type
                    case 'quad'
                        MSH(3,1).elem(ngr(3),1).type='quad';
                        MSH(3,1).elem(ngr(3),1).id=[];
                        MSH(3,1).elem(ngr(3),1).id=[MSH(3,1).elem(ngr(3),1).id;...
                            MSH_2d(3,1).elem(jj,1).id];
                            MSH(3,1).elem(ngr(3),1).id=[MSH(3,1).elem(ngr(3),1).id;...
                                MSH_2d(3,1).elem(jj,1).id+(Nl-1)*Np_per_lay];
                            ngr(3)=ngr(3)+1;
                    case 'triangle'
                        MSH(3,1).elem(ngr(3),1).type='triangle';
                        MSH(3,1).elem(ngr(3),1).id=[];
                        MSH(3,1).elem(ngr(3),1).id=[MSH(3,1).elem(ngr(3),1).id;...
                            MSH_2d(3,1).elem(jj,1).id];
                        MSH(3,1).elem(ngr(3),1).id=[MSH(3,1).elem(ngr(3),1).id;...
                            MSH_2d(3,1).elem(jj,1).id+(Nl-1)*Np_per_lay];
                        ngr(3)=ngr(3)+1;
                end
                %Last create the prism or hexahedrals
                switch MSH_2d(3,1).elem(jj,1).type
                    case 'quad'
                        %create 27 node hexahedral
                        MSH(4,1).elem(ngr(4),1).type='hex';
                        MSH(4,1).elem(ngr(4),1).id=[];
                        for k=1:Nlay-1
                            b=(2*k-2)*Np_per_lay+MSH_2d(3,1).elem(jj,1).id;
                            a=2*k*Np_per_lay+MSH_2d(3,1).elem(jj,1).id;
                            c=(2*k-1)*Np_per_lay+MSH_2d(3,1).elem(jj,1).id;
                            MSH(4,1).elem(ngr(4),1).id=[MSH(4,1).elem(ngr(4),1).id; ...
                                a(:,1) a(:,2) a(:,3) a(:,4) b(:,1) b(:,2) b(:,3) b(:,4) ...
                                a(:,5) a(:,6) a(:,7) a(:,8) b(:,5) b(:,6) b(:,7) b(:,8) ...
                                c(:,1) c(:,2) c(:,3) c(:,4) c(:,5) c(:,6) c(:,7) c(:,8)...
                                a(:,9) b(:,9) c(:,9)];

                        end
                    case 'triangle'
                        %create 18 node prism
                        MSH(4,1).elem(ngr(4),1).type='prism';
                        MSH(4,1).elem(ngr(4),1).id=[];
                        for k=1:Nlay-1
                            b=(2*k-2)*Np_per_lay+MSH_2d(3,1).elem(jj,1).id;
                            a=2*k*Np_per_lay+MSH_2d(3,1).elem(jj,1).id;
                            c=(2*k-1)*Np_per_lay+MSH_2d(3,1).elem(jj,1).id;
                            MSH(4,1).elem(ngr(4),1).id=[MSH(4,1).elem(ngr(4),1).id; ...
                                a(:,1) a(:,2) a(:,3) b(:,1) b(:,2) b(:,3)...
                                a(:,4) a(:,5) a(:,6) b(:,4) b(:,5) b(:,6) ...
                                c(:,1) c(:,2) c(:,3) c(:,4) c(:,5) c(:,6)];

                        end
                end
            end
        end
        
    case 'incomplete'
        %%This need to be completed
        %First extrude the points
        Nlay=length(t);
        Np_edge=length(unique((MSH_2d(3,1).elem.id(:,1:4))));%
        Np_per_lay=size(p_2d,1);
        Z=nan(Np_per_lay,Nlay);
        Z(:,1)=top;
        Z(:,Nlay)=bot;
        for i=2:Nlay-1;
            Z(:,i)=Z(:,Nlay)+(Z(:,1)-Z(:,Nlay))*(1-t(i));
        end

        Np=Np_per_lay*Nlay;
        p=nan(Np,3);
        for i=1:Nlay
            p((i-1)*Np_per_lay+1:i*Np_per_lay,:)=[p_2d(:,1:2) Z(:,i)];
        end
        
            
end

        

            
        
        
    

